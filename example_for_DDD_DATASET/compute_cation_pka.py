import pandas as pd
import os
import subprocess
import re
from pathlib import Path

def run_propka_and_extract_pka(pdb_file, residue_info):
    """
    Run propka3 on a PDB file and extract the pKa value for a specific residue.
    
    Args:
        pdb_file: Path to the PDB file
        residue_info: String in format like "ARG-264-A"
    
    Returns:
        pKa value as float, or None if not found
    """
    # Extract residue name, number, and chain from residue_info
    match = re.match(r'([A-Z]+)-(\d+)-([A-Z])', residue_info)
    if not match:
        print(f"Invalid residue format: {residue_info}")
        return None
    
    res_name = match.group(1)
    res_num = int(match.group(2))
    chain_id = match.group(3)
    
    # Create the .pka filename based on the PDB filename
    pka_filename = pdb_file.replace('.pdb', '.pka')
    
    # Check if .pka file already exists
    if os.path.exists(pka_filename):
        print(f"Using existing .pka file: {pka_filename}")
    else:
        # Run propka3 to generate the .pka file
        try:
            result = subprocess.run(['propka3', pdb_file], 
                                  capture_output=True, text=True, check=True)
            print(f"Propka3 completed for {pdb_file}")
        except subprocess.CalledProcessError as e:
            print(f"Error running propka3 on {pdb_file}: {e}")
            print(f"stdout: {e.stdout}")
            print(f"stderr: {e.stderr}")
            return None
        except FileNotFoundError:
            print("propka3 command not found. Please make sure propka3 is installed and in PATH.")
            return None

    # Extract pKa from the .pka file (either existing or newly created)
    pka_value = extract_pka_from_propka_file(pka_filename, residue_info)
    return pka_value

def extract_pka_from_propka_file(propka_file, residue_info):
    """
    Extract pKa from a propka-generated .pka file.
    
    Args:
        propka_file: Path to the .pka file generated by propka
        residue_info: String in format like "ARG-264-A"
    
    Returns:
        pKa value as float, or None if not found
    """
    # Extract residue name, number, and chain from residue_info
    match = re.match(r'([A-Z]+)-(\d+)-([A-Z])', residue_info)
    if not match:
        print(f"Invalid residue format: {residue_info}")
        return None
    
    res_name = match.group(1)
    res_num = int(match.group(2))
    chain_id = match.group(3)
    
    try:
        with open(propka_file, 'r') as file:
            lines = file.readlines()
            
            # Look for the summary section which typically contains the pKa values
            in_summary = False
            for line in lines:
                if line.startswith('SUMMARY OF THIS PREDICTION'):
                    in_summary = True
                    continue
                
                if in_summary and line.strip() and not line.startswith('Group'):
                    # Parse the line - format is typically: ResidueNum Chain pKa model-pKa
                    parts = line.split()
                    if len(parts) >= 3:
                        # Check if this line contains our target residue
                        # The format might be like "ARG264 A" or "ARG 264"
                        first_part = parts[0]
                        second_part = parts[1] if len(parts) > 1 else ""
                        
                        # Handle different formats: "ARG264" vs "ARG 264"
                        if first_part.startswith(res_name) and second_part == chain_id:
                            # Format: "ARG264 A pKa"
                            res_name_num = first_part
                            found_res_name = ''
                            found_res_num = ''
                            for i, char in enumerate(res_name_num):
                                if char.isdigit():
                                    found_res_name = res_name_num[:i]
                                    found_res_num = res_name_num[i:]
                                    break
                            
                            if found_res_name == res_name and int(found_res_num) == res_num:
                                try:
                                    return float(parts[2])
                                except ValueError:
                                    continue
                        elif first_part == res_name and second_part.isdigit() and len(parts) > 2 and parts[2] == chain_id:
                            # Format: "ARG 264 A pKa"
                            if int(second_part) == res_num:
                                try:
                                    return float(parts[3])
                                except ValueError:
                                    continue
                        elif first_part == res_name and second_part.isdigit() and len(parts) > 1:
                            # Format: "ARG 264 pKa" (when chain is not present or at the end)
                            if int(second_part) == res_num:
                                try:
                                    if len(parts) > 2:
                                        return float(parts[2])
                                    else:
                                        continue
                                except ValueError:
                                    continue
                            
    except FileNotFoundError:
        print(f"Propka file {propka_file} not found")
        return None
    except Exception as e:
        print(f"Error reading propka file: {e}")
        return None
    
    return None

def process_csv_and_add_pka(input_csv, output_csv):
    """
    Process the CSV file, run propka3 on each PDB file, add pKa values as a new column,
    and save only rows with pKa > 7.4 to the output CSV.
    
    Args:
        input_csv: Path to input CSV file
        output_csv: Path to output CSV file with added pKa column (only pKa > 7.4)
    """
    # Read the CSV file
    df = pd.read_csv(input_csv)
    
    # Create a new column for pKa values
    df['pKa'] = None
    
    # Get the current working directory to return to later
    original_dir = os.getcwd()
    
    for index, row in df.iterrows():
        directory = row['Directory']
        protein_info = row['Protein']
        
        print(f"Processing {directory}, residue {protein_info}")
        
        # Change to the directory
        try:
            os.chdir(directory)
        except FileNotFoundError:
            print(f"Directory {directory} not found, skipping...")
            continue
        
        # Find the *_only_protein.pdb file
        pdb_files = [f for f in os.listdir('.') if f.endswith('_only_protein.pdb')]
        if not pdb_files:
            print(f"No *_only_protein.pdb file found in {directory}, skipping...")
            os.chdir(original_dir)
            continue
        
        pdb_file = pdb_files[0]  # Use the first match
        print(f"Found PDB file: {pdb_file}")
        
        # Run propka3 and get pKa
        pka_value = run_propka_and_extract_pka(pdb_file, protein_info)
        
        # Check if pKa is <= 7.4 and print if so
        if pka_value is not None:
            if pka_value <= 7.4:
                print(f"WARNING: Residue {protein_info} in {directory} has pKa = {pka_value:.2f} (<= 7.4) - Will be filtered out")
            else:
                print(f"Residue {protein_info} in {directory} has pKa = {pka_value:.2f} (> 7.4) - Will be included")
        else:
            print(f"Could not determine pKa for {protein_info} in {directory}")
        
        # Update the DataFrame with the pKa value
        df.at[index, 'pKa'] = pka_value
        
        # Return to original directory
        os.chdir(original_dir)
    
    # Filter the dataframe to include only rows with pKa > 7.4
    filtered_df = df[df['pKa'].notna() & (df['pKa'] > 7.4)]
    
    # Print summary of filtered results
    print(f"\nOriginal number of entries: {len(df)}")
    print(f"Entries with pKa > 7.4: {len(filtered_df)}")
    print(f"Entries filtered out (pKa <= 7.4): {len(df) - len(filtered_df)}")
    
    # Show which entries were filtered out
    low_pka_entries = df[df['pKa'].notna() & (df['pKa'] <= 7.4)]
    if not low_pka_entries.empty:
        print("\nFiltered out entries (pKa <= 7.4):")
        for _, row in low_pka_entries.iterrows():
            print(f"  {row['Protein']} in {row['Directory']}: pKa = {row['pKa']:.2f}")
    else:
        print("\nNo entries were filtered out (no pKa <= 7.4 found)")
    
    # Save the filtered CSV (only entries with pKa > 7.4)
    filtered_df.to_csv(output_csv, index=False)
    print(f"\nFiltered output saved to {output_csv} with {len(filtered_df)} entries")

# Usage
input_csv = "reference_experimental_pication_interactions_report.csv"
output_csv = "reference_experimental_pication_interactions_report_with_pka_filtered.csv"
process_csv_and_add_pka(input_csv, output_csv)
